<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Siri Wave Sphere — Оптимизированная версия</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 30% 25%, #0b1420 0%, #0a0f1a 55%, #0a0d16 70%, #0a0a0f 100%),
                  radial-gradient(900px 700px at 90% 60%, rgba(90, 10, 20, 0.55), transparent 60%),
                  #0a0d14;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #dbeafe;
    }
    .wrap {
      height: 100%;
      display: grid;
      place-items: center;
      position: relative;
    }
    .panel {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(10, 12, 18, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.15);
      backdrop-filter: blur(6px);
      border-radius: 14px;
      padding: 10px 12px;
      align-items: center;
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }
    .btn {
      appearance: none;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(30, 41, 59, .55);
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      letter-spacing: .02em;
      transition: background 0.2s ease;
    }
    .btn:hover { background: rgba(45, 55, 72, .6); }
    .btn[aria-pressed="true"] {
      background: linear-gradient(180deg, rgba(59,130,246,.35), rgba(59,130,246,.15));
      border-color: rgba(147,197,253,.45);
    }
    .info {
      font-size: 12px;
      color: #94a3b8;
      margin-left: 4px;
      user-select: none;
    }
    canvas {
      width: min(84vmin, 720px);
      height: min(84vmin, 720px);
      display: block;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="sphere"></canvas>
    <div class="panel" role="toolbar" aria-label="controls">
      <button id="idle" class="btn" aria-pressed="true">Idle</button>
      <button id="active" class="btn" aria-pressed="false">Active</button>
      <button id="mic" class="btn" aria-pressed="false">Mic</button>
      <span class="info" id="msg"></span>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('sphere');
      const ctx = canvas.getContext('2d', { alpha: true });

      const TAU = Math.PI * 2;
      const PI = Math.PI;
      const lerp = (a, b, t) => a + (b - a) * t;
      const clamp = (x, min, max) => Math.min(max, Math.max(min, x));

      const state = {
        mode: 'idle',
        amp: 0.18,
        targetAmp: 0.18,
        time: 0
      };

      let dpr = Math.min(2, window.devicePixelRatio || 1);

      const resizeCanvas = () => {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };
      new ResizeObserver(resizeCanvas).observe(canvas);
      resizeCanvas();

      function strokeCircle(cx, cy, r) {
        const gradient = ctx.createConicGradient(-PI / 2, cx, cy);
        gradient.addColorStop(0, 'rgba(255,255,255,0.6)');
        gradient.addColorStop(0.4, 'rgba(255,255,255,0.22)');
        gradient.addColorStop(0.7, 'rgba(255,255,255,0.08)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.stroke();
      }

      function fillSphereBase(cx, cy, r) {
        const gradient = ctx.createRadialGradient(cx, cy * 1.08, r * 0.1, cx, cy, r);
        gradient.addColorStop(0, '#0d1a28');
        gradient.addColorStop(0.5, '#0b1522');
        gradient.addColorStop(0.8, '#09111c');
        gradient.addColorStop(1, '#070d15');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();
      }

      function addGleams(cx, cy, r) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const colorGleam = ctx.createRadialGradient(cx - r * 0.68, cy + r * 0.58, 10, cx - r * 0.6, cy + r * 0.5, r * 0.92);
        colorGleam.addColorStop(0.0, 'rgba(0, 220, 255, 0.16)');
        colorGleam.addColorStop(0.32, 'rgba(255, 115, 185, 0.14)');
        colorGleam.addColorStop(0.58, 'rgba(255, 210, 110, 0.1)');
        colorGleam.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = colorGleam;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();
        ctx.restore();
      }

      function drawWaves(cx, cy, r, time, intensity) {
        const startX = cx - r;
        const waveWidth = r * 2;
        const numLayers = Math.floor(16 + intensity * 8);
        const numPoints = 120;
        const maxHeight = 12 + intensity * 90;
        const waveGradient = ctx.createLinearGradient(startX, cy, startX + waveWidth, cy);
        waveGradient.addColorStop(0, 'rgba(0, 220, 255, 1)');
        waveGradient.addColorStop(0.28, 'rgba(80, 180, 255, 1)');
        waveGradient.addColorStop(0.52, 'rgba(160, 120, 255, 1)');
        waveGradient.addColorStop(0.75, 'rgba(220, 110, 200, 1)');
        waveGradient.addColorStop(1, 'rgba(255, 120, 180, 1)');

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.clip();

        if (intensity > 0.2) {
          ctx.globalCompositeOperation = 'screen';
          ctx.shadowBlur = 10 + intensity * 12;
          ctx.shadowColor = 'rgba(140,110,255,0.12)';
        }

        for (let layer = 0; layer < numLayers; layer++) {
          const layerPos = layer / (numLayers - 1);
          const depth = 1 - Math.abs(layerPos - 0.5) * 2;
          const alpha = lerp(0.2, 0.75, depth) * lerp(0.55, 1.0, intensity);
          const yOffset = (layerPos - 0.5) * maxHeight * 0.9;
          const speed = 0.85 + (layer % 3) * 0.1;
          const phase = layerPos * PI * 1.3;
          ctx.globalAlpha = alpha;
          ctx.lineWidth = lerp(0.6, 1.3, intensity);
          ctx.strokeStyle = waveGradient;
          ctx.setLineDash((layer % 5 === 0 && intensity > 0.4) ? [3, 6] : []);
          ctx.beginPath();

          for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const x = startX + t * waveWidth;
            const wave1 = Math.sin(t * PI * 2.8 + time * 2.2 * speed + phase);
            const wave2 = Math.sin(t * PI * 5.6 - time * 1.2 * speed + phase * 1.1);
            const envelope = Math.pow(Math.sin(t * PI), 1.5);
            const y = cy + yOffset + (wave1 * 0.7 + wave2 * 0.3) * maxHeight * envelope;
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }

          ctx.stroke();
        }

        ctx.restore();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = 'source-over';
      }

      let audioCtx = null;
      let analyser = null;
      let micStream = null;
      let timeData = null;

      const animate = () => {
        state.time += 1 / 60;

        if (state.mode === 'mic' && analyser && timeData) {
          analyser.getByteTimeDomainData(timeData);
          let sum = 0;
          for (let i = 0; i < timeData.length; i++) {
            const val = (timeData[i] - 128) / 128;
            sum += val * val;
          }
          const rms = Math.sqrt(sum / timeData.length);
          const target = clamp((rms - 0.01) * 4.5, 0, 1);
          state.targetAmp = lerp(0.12, 0.95, target);
        } else {
          const baseAmp = state.mode === 'active' ? 0.75 : 0.15;
          const breathe = Math.sin(state.time * 0.65);
          state.targetAmp = baseAmp + breathe * (state.mode === 'active' ? 0.05 : 0.008);
        }

        state.amp += (state.targetAmp - state.amp) * 0.08;

        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const cx = w / 2;
        const cy = h / 2;
        const r = Math.min(w, h) * 0.46;

        ctx.clearRect(0, 0, w, h);
        fillSphereBase(cx, cy, r);
        drawWaves(cx, cy, r, state.time, state.amp);
        addGleams(cx, cy, r);
        strokeCircle(cx, cy, r);

        requestAnimationFrame(animate);
      };

      requestAnimationFrame(animate);

      const idleBtn = document.getElementById('idle');
      const activeBtn = document.getElementById('active');
      const micBtn = document.getElementById('mic');
      const msg = document.getElementById('msg');

      const setPressed = (btn, pressed) => btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');

      const startMic = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          micStream = stream;
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 1024;
          analyser.smoothingTimeConstant = 0.9;
          source.connect(analyser);
          timeData = new Uint8Array(analyser.frequencyBinCount);
          msg.textContent = 'Микрофон включен';
          state.mode = 'mic';
          setPressed(idleBtn, false); setPressed(activeBtn, false); setPressed(micBtn, true);
        } catch {
          msg.textContent = 'Нет доступа к микрофону';
          state.mode = 'active';
          setPressed(idleBtn, false); setPressed(activeBtn, true); setPressed(micBtn, false);
        }
      };

      const stopMic = () => {
        if (micStream) micStream.getTracks().forEach(track => track.stop());
        if (audioCtx) audioCtx.close();
        micStream = null; audioCtx = null; analyser = null; timeData = null;
      };

      idleBtn.addEventListener('click', () => {
        stopMic(); state.mode = 'idle';
        setPressed(idleBtn, true); setPressed(activeBtn, false); setPressed(micBtn, false);
        msg.textContent = '';
      });

      activeBtn.addEventListener('click', () => {
        stopMic(); state.mode = 'active';
        setPressed(idleBtn, false); setPressed(activeBtn, true); setPressed(micBtn, false);
        msg.textContent = '';
      });

      micBtn.addEventListener('click', () => {
        if (state.mode === 'mic') {
          stopMic(); state.mode = 'idle';
          setPressed(idleBtn, true); setPressed(activeBtn, false); setPressed(micBtn, false);
          msg.textContent = '';
        } else {
          startMic();
        }
      });

      window.addEventListener('pagehide', stopMic);
    })();
  </script>
</body>
</html>
